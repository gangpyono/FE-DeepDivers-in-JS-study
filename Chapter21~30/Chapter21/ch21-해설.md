# Chapter21 빌트인 객체
## 📌문제1
### 다음 코드의 출력 결과를 예측하세요.

```js
isFinite(0); // (1)
isFinite(null); // (2)
isFinite(NaN); // (3)
isFinite(Infinity); // (4)

isNaN(null); // (5)
isNaN(undefined); // (6)
isNaN(""); // (7)
isNaN(new Date()); // (8)
isNaN(new Date().toString()); // (9)
```
### 정답 및 해설
```
331p
isFinite는 전달받은 인수가 정상적인 유한수인지 검사하여 유한수이면 true를 반환하고
무한수 또는 NaN으로 평가되는 값이라면 false를 반환한다.
(1) true
(2) true
(3) false
(4) false

332p
isNaN은 전달받은 인수가 NaN인지 검사한다.
전달받은 인수의 타입이 숫자가 아닌 경우 숫자로 타입을 변환한 후 검사를 수행한다.
(5) false : null은 0으로 타입변환
(6) true
(7) false : 빈문자열은 0으로 타입변환
(8) false : new Date()는 Number로 타입변환
(9) true : String은 NaN
```

<br>

## 📌문제2
### 다음 코드를 참고하여 식별자 `x`, `y`의 차이점을 설명하시오.
```js
console.log(x); // (1)
console.log(y); // (2)

var x = 10;

function foo () {
  y = 20;
}
foo();

console.log(x + y); // (3)
```
### 정답 및 해설
```
x는 전역 변수이고, y는 전역 객체의 프로퍼티입니다.
왜냐하면 자바스크립트 엔진이 foo함수를 실행하여 y변수를 스코프 체인을 통해 참조하려고 찾지만 없으므로 `y = 20;`을 `window.y = 20;`으로 해석하여 전역 객체에 프로퍼티를 동적 생성하게 됩니다.

따라서 x는 변수 호이스팅이 발생하고, y는 발생하지 않습니다.

또한 x는 delete 연산자로 삭제할 수 없고, y는 가능합니다.
```
- p339 ~ p341

<br>

## 📌문제3
### 문자열, 숫자, 불리언은 원시값이 있는데도 표준 빌트인 생성자 함수가 존재한다. 그 이유를 설명하고 원시값을 객체처럼 사용할 때 어떠한 일이 일어나는지 `래퍼객체` 라는 단어를 사용해 설명하시오.

### 답안 작성
```
원시값인 문자열, 숫자, 불리언 값의 경우 이들 원시값에 대해 마치 객체처럼 마침표 표기법으로 접근하면 자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환해주기 때문이다. 원시값을 객체처럼 사용하면 자바스크립트 엔진은 원시값과 연관된`래퍼 객체`를 생성해 생성된 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌린다.
```

<br>
