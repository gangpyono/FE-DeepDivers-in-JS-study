# Chapter34

## 📌문제1. true or false, 출력결과물을 작성해주세요.

### 문제 작성

```
ES6에서는 순회 가능한 데이터 컬렉션을 이터레이션 프로토콜을 준수하는 이터러블로 통일하여 for...in문,스프레드 문법객체 디스트럭처링 할당의 대상으로 사용할 수 있도록 일원화 했다.
```

```js
const obj = { 0: 1, 1: 2, length: 2 };
const iter = obj[Symbol.iterator]();
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
```

### 정답 및 해설

```
- false
  for...in -> for...of
  객체 -> 배열


- TypeError: obj[Symbol.iterator] is not a function
 일반 객체에는 Symbol.iterator메서드를 구현하거나 상속 받지 않는다.
```

<br>

## 📌문제2. 이터러블,이터레이터,이터러블 이면서 이터레이터를 판단해주세요.

### 문제 작성

```js
const f1 = (first, max) => {
  let num = first;
  return {
    [Symbol.iterator]() {
      return {
        next() {
          num += 1;
          return { value: num, done: num > max };
        },
      };
    },
  };
};

const test = f1(0, 10); //(1)

const test1 = test[Symbol.iterator](); // (2)

const f2 = (first, max) => {
  let num = first;

  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      num += 1;
      return { vaule: num, done: num > max };
    },
  };
};

const test3 = f2(0, 10); // (3)
```

### 정답 및 해설

```
(1): 이터러블
 -> Symbol.iteraor를 키로갖는 메서드를 가지며, 이를 호출했을떄 이터레이터 프로토콜을 따르는 이터레이터를 갖기때문에 이터레이터 프로토콜이란, next라는 이름의 메서드(호출했을떄 {value : _ , done : _ }객체를 리턴)를 갖는 객체를 의미.

 (2): 이터레이터
 -> next라는 이름의 메서드(호출했을떄 {value : _ , done : _ }객체를 리턴)를 갖기 때문에.

 (3): 이터러블이면서 이터레이터
 -> 이터레이터 프로토콜을 따르는 이터레이터를 반환하는 Symbol.iterator를키로하는 메서드를 가지고 있고(이터러블) 동시에 {value: _, done: _ }를 리턴하는 next메서드를 가지고 있기때문.(이터레이터)
```

<br>

## 📌문제3

### 이터레이션 프로토콜의 필요성에 대해 설명해보세요.

### 답안 작성

```
교재 621p
이터레이션 프로토콜은 다양한 데이터 공급자가 하나의 순회 방식을 갖도록 규정하여
데이터 소비자가 효율적으로 다양한 데이터 공급자를 사용할 수 있도록
데이터 소비자와 데이터 공급자를 연결하는 인터페이스 연결을 한다.
```

<br>
