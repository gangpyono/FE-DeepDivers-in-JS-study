# Chapter34

## 📌문제1. true or false, 출력결과물을 작성해주세요.

### 문제 작성

```
ES6에서는 순회 가능한 데이터 컬렉션을 이터레이션 프로토콜을 준수하는 이터러블로 통일하여 for...in문,스프레드 문법,
객체 디스트럭처링 할당의 대상으로 사용할 수 있도록 일원화 했다.
- true or false // (1)
```

```js
const obj = { 0: 1, 1: 2, length: 2 };
const iter = obj[Symbol.iterator]();
console.log(iter.next()); //(2)
console.log(iter.next()); //(3)
console.log(iter.next()); //(4)
```

### 정답 및 해설

```
(1):
(2):
(3):
(4):
```

<br>

## 📌문제2. true or false, 출력결과물을 작성해주세요.

### 문제 작성

```js
const f1 = (first, max) => {
  let num = first;
  return {
    [Symbol.iterator]() {
      return {
        next() {
          num += 1;
          return { value: num, done: num > max };
        },
      };
    },
  };
};

const test = f1(0, 10); //(1)

const test1 = test[Symbol.iterator](); // (2)

const f2 = (first, max) => {
  let num = first;

  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      num += 1;
      return { vaule: num, done: num > max };
    },
  };
};

const test3 = f2(0, 10); // (3)
```

### 정답 및 해설

```
(1):
(2):
(3):
```

<br>

## 📌문제3

### 이터레이션 프로토콜의 필요성에 대해 설명해보세요.

### 답안 작성

```

```

<br>

## 📌문제4

### 다음 코드의 결과를 쓰시오

```js
const arrayLike = { 
	0 : 1,
	1 : 2,
  	2 : 3,
	length : 3
};
console.log(Symbol.iterator in arrayLike); //(1)
for(const item of obj){ // (2)
	console.log(item);
}
```

### 답안 작성

```
(1) :
(2) : 
```

<br>

## 📌문제5

### 5-1. 다음 코드를 무한 이터러블 생성 함수로 바꾸시오. 

```js
const addOne = function () {
	let cur = 0;
	const max = 10;
	return {
		[Symbol.iterator]() {return this; },
		next() {
			cur = cur + 1;
			return {value : cur, done: cur >= max};
		}
	};
};

for (const num of addOne()){
	if(num > 100) break;
	console.log(num);
}
```

### 답안 작성

```

```

### 5-2. 무한 이터러블은 성능상 문제가 없는가? 문제가 없다면 그 이유는 무엇인지 쓰시오.

### 답안 작성
```

```
