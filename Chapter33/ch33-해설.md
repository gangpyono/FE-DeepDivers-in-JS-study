# Chapter33
## 📌문제1
### true,false를 판단하세요.
```
     (1) 심벌은 원시타입이다.
     (2) 심벌함수를 호출시 인자로 전달받을 수 있는 문자열의 역할은 1.디버깅 2.참조를 위함이다.
     (3) well-known Symbol이란 자바스크립트가 기본 제공하는 빌트인 심벌값을 의미한다.
```
### 답안 작성
```
(1) 심벌은 ES6에서 도입된 7번째 데이터 타입으로 변경 불가능한 원시 타입의 값이다. p.605
(2) Symbol 함수에는 선택적으로 문자열을 인수로 전달 할 수 있다. 이 문자열은 생성된 심벌 값에 대한 설명으로 디버깅 용도로만 사용되며,
    심벌 값 생성에 어떠한 영향을 주지않는다. p.606
(3) Symbol함수의 프로퍼티에 할당되어있다. p.612
```

<br>

## 📌문제2
### 출력 결과물을 예측해 주세요.
```js
   const s1 = Symbol("m1");
   const s2 = Symbol("m1");

   console.log(s1 === s2); // (1)

   const s3 = Symbol.for("mySymbol");
   const s4 = Symbol.for("mySymbol");

   console.log(s3 === s4); // (2)
```
### 답안 작성
```
(1) false -> 심벌값에대한 설명이 같더라도, 생성된 심벌값은 유일무이한 값이다. p.606
(2) true -> Symbol.for메서드는 인수로 전달받은 문자열을 키로 사용하여 키와 심벌 값의 쌍들이 저장되어 있는 전역 심벌 레지스트리에서 
            해당 키와 일치하는 심벌 값을 검색한다. 
            검색후 해당 키로 저장된 심벌값이 있으면 해당 심벌값을 반환하고, 없으면 생성후 반환한다.p607
```

<br>

## 📌문제3

### 코드의 문제점을 찾아 수정하고, 수정 후의 실행 결과를 예측히세요.

```js
const mySymbol = new Symbol();
const yourSymbol = new Symbol();

console.log(mySymbol); // (1)
console.log(yourSymbol); // (2)
console.log(mySymbol === yourSymbol); // (3)

const ourSymbol = Symbol("our symbol");

console.log(mySymbol.description); // (4)
console.log(ourSymbol.description); // (5)
```

### 답안 작성

```
Symbol 함수는 new 연산자와 함께 호출하지 않는습니다.
new 연산자와 함께 호출하면 'TypeError: Symbol is not a constructor'

(1) : Symbol()
(2) : Symbol()
(3) : false
(4) : undefined
(5) : our symbol
```

```
Symbol 함수는 new 연산자와 함께 호출하지 않는습니다.
new 연산자와 함께 호출하면 'TypeError: Symbol is not a constructor'

(3) : 심벌 값에 대한 설명이 같더라도, 생성된 심벌 값은 유일무이한 값입니다.
(4), (5) : 심벌 값에 문자열, 숫자, 불리언과 같이 객체처럼 접근하면 암묵적으로 레퍼 객체를 생성합니다.
```

<br>

